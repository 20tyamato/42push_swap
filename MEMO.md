# push_swap実装方針

## STEPS

- input
  - argc check：OK
  - ./push_swap check：OK
- char：OK
  - space：OK
  - tab：OK
  - minus：OK
  - numbers：OK
- 作業分離：文字列とそうでないもの：OK
- number check：OK
  - INT_MAX check：OK
  - INT_MIN check：OK
    - get as long long：OK
  - LONG_MAX check：OK
  - LONG_MIN check：OK
- duplicate check：OK
- sorted check
- init stacks：OK
- input to stack A：OK
- sort stack A and B
- output merge
- output

## ADD

- 文字列として入力される場合

## THINK

- マイナス値の取り扱い

## Feedback

以下の流れ自体は、大きく間違ってはいないです。ただし、42のpush_swapの要件を踏まえると、いくつかポイントや注意事項があります。おおまかな処理のイメージとしては下記で問題ないと思います。

大まかな流れ
	1.	引数の取得・パース
	•	文字列としてコマンドライン引数を取得。
	•	スペース区切りなど複数の入力パターンがありえるので、まずはそれらを一連の「数字文字列」としてまとめる。
	2.	バリデーション(エラーチェック)
	•	ASCIIチェック: 引数が数字と必要最小限の記号(“+”や“-”)以外を含んでいないか。
	•	数値としてパース: intの範囲をオーバーしていないか (INT_MIN, INT_MAX)。
	•	一時的にlongでチェックしてからintに収まるかどうか確認する方法が一般的です。
	•	重複チェック: 同じ数値が入っていないか。
	•	ソート済みチェック: すでに昇順で並んでいる場合、命令を出力せず終了でOK (push_swapは何も出力しない場合があります)。
	3.	スタック初期化
	•	Aスタックにパース後の整数列を格納する。
	•	Bスタックは最初は空。
	4.	ソート処理 (アルゴリズム本体)
	•	push_swapの本体部分。
	•	スタックA, Bを使った最小限の命令列(操作列)を生成するためのアルゴリズムを実装する。
	•	小さいデータセット(3個, 5個など)はハードコードの単純ソートを採用する場合が多い。
	•	大きいデータセット(100個, 500個など)ではクイックソートやマージソート的な概念をベースに、スタック操作に落とし込んでいく戦略が一般的です。
	5.	命令列の出力
	•	sa, sb, ss, pa, pb, ra, rb, rr, rra, rrb, rrr などの命令を、改行区切りで出力。
	•	これが「checker」で正しく動作するかをテストする。

注意点・アドバイス
	1.	“./push_swap check” という実行方法は基本的に想定されていない
	•	42の課題では、push_swapとcheckerは別々のプログラムです。
	•	普通は ./push_swap [数列] とすると、push_swapがスタックソートに必要な命令列を標準出力に吐きます。
	•	その出力を checker という別のプログラムにパイプで渡し、checker がスタック操作をシミュレーションして OK / KO を返すのが一般的な使い方です。
	•	例: ARG="4 67 3 87 23"; ./push_swap $ARG | ./checker $ARG
	•	もし自前で「チェックモード」をpush_swap内に入れたい場合でも、基本の課題要件とは別の拡張機能になるかもしれません。
	2.	数値チェックは LONG_MAX/LONG_MIN まで厳密にするかどうか
	•	課題では「int型として扱える値のみが有効」という要件なので、最終的には INT_MIN ~ INT_MAX かを判定します。
	•	実装では文字列を一旦long longで変換し、その値が INT_MIN ~ INT_MAX に収まるかどうかチェックするのがよくあるパターンです。
	•	longが環境によって32bitか64bitか変わる場合があるので、C言語だと long long を使うほうが安全、というのがよくある指摘です。
	3.	sortedチェックは、スタック初期化後にまとめてやってもOK
	•	引数を配列などにパースして一通り検証が終わってから、「もうソート済みかどうか」をチェックして何もしないで終了する、という流れが楽です。
	•	これは命令を一切出力しない(空出力)状態が「すでにソートされている」という正しい動作になるからです。
	4.	出力は必ず命令のみ
	•	push_swapが吐く標準出力には、追加でprintfデバッグやエラー表示などを混ぜると、checkerで正しく動かなくなります。
	•	エラーの場合は、課題仕様に従い ft_putstr_fd("Error\n", 2); exit(1); のような処理が一般的かと思いますが、標準エラーに吐くようにし、標準出力には混在させないように注意してください。
	5.	アルゴリズムの実装部分が最大の山場
	•	push_swapはアルゴリズムの最適化が最大のポイントです。
	•	小規模(3個,5個, etc.)はバブルソート的に直接ハードコードしてもいいですが、大規模テスト(100個,500個)では「どれだけ手数を減らせるか」でスコアが変わります。
	•	一般的には「分割 (partition) → プッシュ → 回転」の組み合わせを駆使したクイックソートライク、もしくは「インデックス圧縮（座圧）」＋「バケットソート」形式などが有名です。

まとめ
	•	書かれている 「入力 → バリデーション → ソートアルゴリズム → 出力」 の流れは、push_swapとしては大筋正しいです。
	•	ただし、実際は push_swap と checker は別プログラムとして扱われ、ソート命令だけを標準出力に書き出すのが基本。
	•	“ascii check”、“number check”などのバリデーションはまとめてもOK。最終的には「数値の形式」→「int範囲」→「重複なし」→「ソート済みチェック」という流れを確実にやるのが大事です。
	•	ソートアルゴリズム部分が最重要なので、そこに時間をかけましょう。

このように進めればOKです。がんばってください。

./push_swap 0 11 2
- 0
- 11
- 2
- sa
- 11
- 0
- 2
- ra
- 0
- 2
- 11

The first argument should be at the top of the stack (be careful about the order).
